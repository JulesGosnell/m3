I have a pure Clojure open source project - https://github.com/JulesGosnell/m3 - I would like your help to develop it.

PROJECT VISION:
My goal is to create a 100% (there are a couple of things I can't do - because of e.g. the behaviour of numbers in js etc) compliant library that will give (as far as possible) identical results in back (clojure) and front (clojurescript) ends... It will be small, fast and completely extensible.

================================================================================
CLAUDE PROCESS GUIDE
================================================================================

## Session Setup

When starting a new session, Claude should:
1. Check environment versions:
   - Leiningen version: `lein version` (currently 2.11.2)
   - Java version: `java -version` (currently OpenJDK 21.0.8 LTS)
2. Run the tests: `lein test` (CLJ) and `lein test-cljs` (CLJS)
3. Check for dependency updates: `lein ancient` (plugin now installed)
4. Review recent git commits: `git log --oneline -15`
5. Review this file (CLAUDE.txt) for context
6. Check for any uncommitted changes: `git status`
7. Check GitHub Actions build status: https://github.com/JulesGosnell/m3/actions
   - Priority to keep builds green

Note: Cider/Emacs updates can be handled separately as needed.

## Code Changes Process

**IMPORTANT**: Always follow this process when making code changes:

1. **Before Making Changes**:
   - Understand the existing code structure and patterns
   - Review related test files to understand expected behavior
   - Consider the impact on both CLJ and CLJS platforms

2. **After Making Changes**:
   - Run tests: `lein test` and `lein test-cljs`
   - Verify tests still pass with same assertion count
   - Check for any new warnings in test output

3. **CODE REVIEW REQUIRED**:
   - **DO NOT COMMIT** without user review
   - Present the changes to the user with:
     * Summary of what was changed
     * Rationale for the approach taken
     * Any trade-offs or alternatives considered
   - Wait for user approval or feedback
   - Be prepared to revise based on user input

4. **After Review Approval**:
   - Only then use `git add` and `git commit`
   - Write clear, detailed commit messages that explain the why, not just the what
   - Reference any relevant issue numbers or prior commits

5. **New Files**:
   - When creating a new code file, copy in a Copyright notice from an existing file

Remember: The user may have better approaches or additional context that could improve the solution. Code review is a learning opportunity for both parties.

================================================================================

CURRENT TEST BASELINE (September 2, 2025):
- Clojure: 24,061 assertions, 0 failures, 0 errors (~1 minute runtime)
- ClojureScript: 24,061 assertions, 0 failures, 0 errors
- Full cross-platform parity achieved

ARCHITECTURE OVERVIEW:

## Core Components:

1. **validate.cljc** (1250+ lines)
   - Central validation engine with compile-m2 function (inside large let block near bottom)
   - Implements L2/L1 curried pattern: (fn [c2 p2 m2] ...(fn [c1 p1 m1]...))
   - Schema compilation vs runtime validation separation
   - Contains interceptor pattern for ref/anchor handling
   - json-walk function for marker discovery (to be replaced)
   - Uses make-property->index-and-check for property dispatch

2. **property.cljc** (700+ lines) 
   - All property checker implementations (71 check-property-* functions)
   - Each follows L2/L1 curried pattern for compilation/runtime separation
   - Handles all JSON Schema keywords across all drafts
   - Special handling for content-* properties with encoding/decoding
   - Complex logic for dependencies, conditionals, and unevaluated properties

3. **vocabulary.cljc** (400+ lines)
   - Data-driven vocabulary system with draft->vocab-and-group-and-property-and-semantics table
   - Contains historically accurate vocabulary definitions for all drafts (3, 4, 6, 7, 2019-09, 2020-12, next)
   - Implements topological sorting based on property dependencies
   - make-dialect function for composing vocabularies into validation dialects
   - Each entry: [vocabulary-uri, group, property-name, checker-function, dependencies-set]

4. **ref.cljc**
   - Reference resolution logic ($ref, $recursiveRef, $dynamicRef)
   - URI resolution and fragment handling
   - Path-based reference tracking

5. **util.cljc**
   - topo-sort-by for dependency-based topological sorting
   - Error creation utilities
   - Helper functions (absent, present?, concatv, etc.)

6. **type.cljc**
   - JSON type checking (json-number?, json-string?, json-array?, json-object?)
   - Type validation and type checker creation

7. **format.cljc**
   - Format validators for all JSON Schema format strings
   - Platform-specific implementations for CLJ/CLJS

8. **uri.cljc**
   - URI parsing and resolution
   - Base URI inheritance logic

## Key Design Patterns:

1. **L2/L1 Curried Functions**:
   - Level 2 (L2): Schema compilation time - processes schema (m2)
   - Level 1 (L1): Runtime validation - processes document (m1)
   - Enables caching of compiled schemas via closures
   - Example: `(fn [c2 p2 m2 v2] ... (fn [c1 p1 m1] ...))`

2. **Context Threading**:
   - c2: Compilation context (dialect, draft, uri->schema, etc.)
   - c1: Runtime context (accumulated state, errors, markers)
   - Context flows through validation via reduction

3. **Interceptor Pattern**:
   - Used for $ref, $anchor, $dynamicAnchor handling
   - Allows pre/post processing around property validation

4. **Data-Driven Vocabulary**:
   - Entire dialect composition driven by vocabulary table
   - Properties sorted topologically by dependencies
   - Extensible via vocabulary URIs

## Vocabulary System Details:

The vocabulary table has been meticulously reconciled against official JSON Schema metaschemas (August 2025):
- Draft-03: 40 properties (includes divisibleBy, disallow, extends)
- Draft-04: 37 properties (removed Draft-03 specific keywords)
- Draft-06: 41 properties (added contains, const, propertyNames, $id)
- Draft-07: 48 properties (added if/then/else, $comment, examples, content keywords)
- Draft-2019-09: 55 properties (added $anchor, $defs, $vocabulary, $recursiveRef/Anchor, unevaluated*)
- Draft-2020-12: 53 properties (replaced $recursiveRef/Anchor with $dynamicRef/Anchor, added prefixItems)
- Draft-next: Same as 2020-12

Key dependency relationships identified:
- Identity dependencies: id/$id → $anchor → $ref
- Conditional dependencies: if → then/else
- Content dependencies: contentMediaType → contentEncoding → contentSchema
- Evaluation tracking: various → unevaluatedProperties/Items

## Current Technical Challenges:

### 1. Marker Collection Architecture Issue
**Problem**: The validator is m2-driven (iterates schema properties), but for recursive schema validation needs to collect markers (id/$id/$anchor) from m1 (the document being validated when it's a schema).

**Current State**: check-property-id/check-property-$id/check-property-$anchor functions exist but aren't called when needed during recursive validation because they're triggered by m2 properties, not m1.

**Proposed Solution**: Recursive ascent of schema hierarchy with marker stash passing via c1 → c2 transfer between validation levels.

### 2. JSON-walk Replacement
**Problem**: Current json-walk is not sufficiently JSON-aware and mistakes IDs/anchors in enums and unknown fields.

**Status**: On hold while focusing on vocabulary implementation which may naturally solve this.

### 3. Vocabulary Implementation ($vocabulary support)
**Current Focus**: Getting $vocabulary working to enable:
- Dynamic dialect composition
- Feature group management
- Different validation strategies (m2-driven, m1-driven, hybrid)
- Merging L2/L1 curried API with interceptor API

### 4. State Passing Constraints
**Constraint**: Validation returns only errors and accumulated context (c1). Any state needed between validation levels must be passed via c1 and copied to next c2.

## Architectural Decisions:

1. **No Mixed Draft Vocabularies**: A dialect must use vocabularies from the same JSON Schema draft version. This prevents keyword conflicts and keeps dependency graphs manageable.

2. **Topological Property Sorting**: Properties are validated in dependency order using topo-sort-by to ensure correct state passing.

3. **Compilation/Runtime Separation**: L2/L1 pattern enables efficient schema compilation and caching.

## Architecture Notes:

### Circular Dependency Resolution
**Current State**: The check-property-XXX functions in property.cljc need to recursively call check-schema from validate.cljc, but validate.cljc also depends on property.cljc. This circular dependency is currently broken using `(deref (resolve 'm3.validate/check-schema))` pattern throughout property.cljc.

**Planned Solution**: Pass a check-schema function (or equivalent - possibly just the dialect function) down through c2 context. This will eliminate the need for runtime resolution and make the dependency flow cleaner and more explicit.

## Project Structure:
```
./ (current working directory)
├── src/
│   ├── clj/      (Clojure-specific code)
│   ├── cljc/m3/  (Cross-platform core - 13 files)
│   └── cljs/     (ClojureScript-specific code)
├── test/
│   ├── cljc/m3/  (Cross-platform tests - 9 files)
│   └── cljs/m3/  (ClojureScript test runners)
├── resources/
│   └── schemas/  (Local copies of official metaschemas)
├── project.clj   (Leiningen configuration)
└── deps.edn     (Clojure deps configuration)
```

## Dependencies Status (August 29, 2025):

Core dependencies appear up-to-date:
- org.clojure/clojure: 1.12.2 (latest stable)
- cheshire/cheshire: 6.0.0 
- thheller/shadow-cljs: 3.2.0
- org.clojure/tools.logging: 1.3.0
- com.widdindustries/cljc.java-time: 0.1.21

Plugins mostly current:
- lein-cloverage: 1.2.4
- com.jakemccrary/lein-test-refresh: 0.26.0
- cider/cider-nrepl: 0.57.0 (may have newer versions)
- refactor-nrepl: 3.11.0

## Recent Git History (last significant changes):
- Vocabulary table reconciliation against official metaschemas
- Dependency sorting implementation for vocabularies
- Addition of missing Draft-03 keywords (divisibleBy, disallow, extends)
- Correction of id vs $id usage across drafts
- Topological sorting of vocabulary properties

## Testing Strategy:
- `lein test` - Full Clojure test suite (24k+ assertions, ~1 minute)
- `lein test-cljs` - ClojureScript tests (periodic platform checks)
- `lein test m3.testsuite-test` - JSON Schema compliance tests (most important)
- `lein cloverage` - Coverage analysis for CLJ platform

The test suite runs the entire official JSON Schema test suite, providing excellent compliance validation.

## Next Development Priorities:

1. **Vocabulary Composition System** ← CURRENT FOCUS
   - Implement dynamic vocabulary composition using the reconciled table
   - Support $vocabulary keyword properly
   - Enable feature group management
   - NEW APPROACH: Use stable-sort for dialect compilation (see below)

2. **Engine Flexibility**
   - Support different validation driving strategies
   - Unify L2/L1 curried API with interceptor API
   - Make validation driver vocabulary-aware

3. **Marker Collection Strategy**
   - Implement recursive schema hierarchy traversal
   - Pass marker stashes via c1 → c2 transfer
   - Replace json-walk with vocabulary-driven approach

4. **Performance Optimization**
   - Leverage topological sorting for better performance
   - Implement memoization strategies
   - Optimize L2/L1 compilation

## NEW APPROACH - Stable Sort for Dialect Compilation (August 29, 2025):

The new `make-stable-sort-by` function in util.cljc enables a cleaner, more efficient approach to dialect-driven validation:

**The Concept**:
1. Extract an ordered sequence of [property-name, property-checker] from the vocabulary/dialect (already topologically sorted)
2. Use `make-stable-sort-by` to compile this into a reusable sorting function
3. Apply this sorter to any schema (m2) to get its properties in correct dependency order with checkers attached

**Benefits**:
- Pre-compiled sort index (cacheable per dialect)
- Single-pass sorting with integrated checker attachment
- Eliminates current reduce-kv → sort-by → map pipeline in compile-m2
- Naturally respects vocabulary-defined dependencies
- More efficient than current index-based approach

**Example implementation sketch**:
```clojure
(defn make-vocabulary-sorter [dialect]
  (let [ordered-properties (get-ordered-properties-from-dialect dialect)]
    (make-stable-sort-by 
      first                    ; k1: extract property name
      ordered-properties)))    ; e1s: ordered template from vocabulary

;; In compile-m2, replace current logic with:
(let [sorter (make-vocabulary-sorter dialect)]
  (sorter key-fn xform-fn (seq m2)))
```

## TODO - Handling Unknown Properties in Stable Sort:

Consider extending `make-stable-sort-by` to accept an additional function parameter for handling e2s not present in e1s (unknown properties). This would allow injecting a warning logger:

```clojure
(make-stable-sort-by k1 e1s unrecognized-fn)
;; where unrecognized-fn could be:
(fn [e2] (log/warn (str "property: unexpected property encountered: " (pr-str (k2 e2)))))
```

This approach is cleaner than returning a separate list of unrecognized elements and maintains the single-pass efficiency while providing proper warning feedback for unknown vocabulary properties.

## Code Quality Notes:

- Extensive use of .cljc for cross-platform code
- Careful platform-specific handling with reader conditionals #?(:clj ... :cljs ...)
- Consistent L2/L1 pattern throughout property checkers
- Data-driven design for extensibility
- Comprehensive test coverage via official test suite

## Key Functions/Vars to Know:

- `compile-m2`: Core schema compilation (in large let block near bottom of validate.cljc)
- `check-schema`: Main validation entry point
- `make-property->index-and-check`: Property dispatcher
- `draft->vocab-and-group-and-property-and-semantics`: Vocabulary table
- `make-dialect`: Vocabulary composition
- `topo-sort-by`: Dependency sorting utility

## Platform Differences to Consider:
- Number handling differences between JVM and JS
- Regex engine differences (Java vs JavaScript)
- Date/time handling variations
- Base64 encoding/decoding implementations

## MCP Tool Usage:
- Project connected via clojure-mcp for local file editing and REPL access
- Can run tests directly via bash tool
- Full read/write access to project files
- REPL available for testing code changes

## Documentation Tasks:
- README needs updating - examples are likely stale
- Need to improve sections on using MCP
- Issues tracker at https://github.com/JulesGosnell/m3/issues needs maintenance

## Recent Progress (September 2025):
- Successfully unified checkers and interceptors architecture
- Interceptors are now integrated into property checkers
- All checkers now follow new unified pattern with L2/L1 adaptation
- Stable sort approach integrated for dialect compilation
- Removed json-walk function that was incorrectly identifying markers
- Tests remain green with increased assertion count (24,061)

## Current Issues/Bugs:

### 1. Missing Dialect Propagation
**Problem**: Having to keep defaulting the dialect - it should pass smoothly down validation, only changing when encountering a $schema field in m2.
**Status**: HIGH PRIORITY - Next item to fix

### 2. Check-property-$ref m2 Mutation Issue
**Problem**: check-property-$ref (and other ref types) may pass out a different m2 than was passed in. This requires revisiting the dialect function with the new m2 because the fields being visited may have changed.
**Solution**: After each check-property-XXX call, perform `(identical? old-m2 new-m2)` check and rerun `(dialect new-m2)` if stale. This requires changes to compile-m2.
**Impact**: Performance cost of re-computing dialect, but necessary for correctness.
**Status**: CRITICAL - This is the key architectural challenge for interceptor-to-property-checker migration. $ref doesn't just validate, it REPLACES the schema.

### 3. Draft Interceptor to check-property-$schema Migration
**Problem**: Current attempt to migrate draft interceptor into check-property-$schema is failing cross-schema tests.
**Status**: ACTIVE INVESTIGATION - Code has been unstashed, debugging in progress

### 4. Missing :draft in Errors
**Problem**: Errors do not contain :draft field which would be helpful for debugging
**Status**: TODO

### 5. Draft-03 Required Property
**Problem**: In draft-03, "required" lives within property definitions, so need to read whole definition beforehand to know if property is required.
**Solution**: Can use same strategy as marker stash - process in m3/m2 validation and pass results into m2/m1 validation.

## Next Development Priorities:

1. **Migrate Interceptor Stack to Property Checkers** ← IMMEDIATE PRIORITY (September 2025)
   - Interceptor stack will be DECOMMISSIONED, not migrated (it's a temporary bridge)
   - All check-property-*, check-type-*, and check-format-* now use new calling protocol
   - This will reduce complexity - only 1 call protocol instead of 2
   - Will reduce dehashes - interceptors currently call dissoc on every pass, property checkers only run when property exists
   - Will tighten validation - dialect will be better fit for $vocabulary
   - Bootstrap strategy: recursive ascent to schema hierarchy top (memoized) on $schema, gather info on descent via c2/c1 threading

2. **Fix c2/c1 Context Threading Issues** ← EXPECT BUGS HERE
   - NOTE: Because we just migrated check-*-* functions to new protocol, c2 and c1 may not thread correctly through validation
   - Bugs are expected in context passing between validation levels
   - Need systematic review of all property checkers for proper context threading

3. **Fix Dialect Propagation Bug**
   - Dialect should flow down validation chain naturally
   - Should only change when $schema is encountered in m2
   - Investigation branch: `compose` has exploratory code

4. **Complete Interceptor/Property-Checker Unification**
   - Now that basic unification is done, compose all into single API
   - Allow all to be ordered and composed into dialect via vocabulary
   - Enable flexible validation driving strategies
   - All check-property-X, check-type-X and check-format-X have been migrated from multimethods to data structures for complete extensibility

5. **Marker Collection Strategy**
   - After unification, implement recursive schema hierarchy traversal  
   - Pass marker stashes (ids, anchors, etc.) via c1 → c2 transfer
   - Fix ref code with gathered stashes

6. **Add :draft to Error Objects**
   - Include draft information in all error objects for better debugging

7. **Fix Draft-03 Required Property Handling**
   - Implement pre-pass to gather required information from property definitions
   - Pass this data through validation levels

This is a well-architected, ambitious project with solid foundations. The vocabulary system is particularly elegant, and the L2/L1 pattern provides excellent separation of concerns. The recent unification of interceptors and property checkers is a major architectural improvement.
