;; Copyright 2025 Julian Gosnell
;;
;; Licensed under the Apache License, Version 2.0 (the "License");
;; you may not use this file except in compliance with the License.
;; You may obtain a copy of the License at
;;
;;     http://www.apache.org/licenses/LICENSE-2.0
;;
;; Unless required by applicable law or agreed to in writing, software
;; distributed under the License is distributed on an "AS IS" BASIS,
;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;; See the License for the specific language governing permissions and
;; limitations under the License.

;; FYI - the code below was mostly generated by Grok4. The first LLM I
;; have found that was able to implement this for me. I did prompt it
;; a lot and I have tweaked some of the code slightly.

(ns m3.idn-hostname
  (:require
   [clojure.string :as str]
   #?(:cljs ["punycode/" :as punycode]))
  #?(:clj
     (:import
      [java.net IDN]
      [java.text Normalizer Normalizer$Form]
      [java.lang Character StringBuilder Character$UnicodeScript])))

;;------------------------------------------------------------------------------
;; common platform

;; TODO: share with validate
#?(:cljs
   (def Exception js/Error))

(def code-point-at
  #?(:clj (fn [s i] (Character/codePointAt s i))
     :cljs (fn [s i] (.codePointAt s i))))

(def char-count
  #?(:clj (fn [cp] (Character/charCount cp))
     :cljs (fn [cp] (if (> cp 0xffff) 2 1))))

(defn string-to-codepoints [s]
  (let [result (transient [])]
    (loop [i 0]
      (if (< i (count s))
        (let [cp (code-point-at s i)]
          (conj! result cp)
          (recur (+ i (char-count cp))))
        (persistent! result)))))

(def normalise-nfkc
  #?(:clj (fn [s] (Normalizer/normalize s Normalizer$Form/NFKC))
     :cljs (fn [s] (.normalize s "NFKC"))))

(def case-fold-map
  {0x00df [0x73 0x73]  ; ß -> ss
   0x03c2 [0x03c3]  ; ς -> σ
   ; Add more as needed, e.g., 0x0130 [0x69 0x307], from CaseFolding.txt
   })

(def string-builder
  #?(:clj (fn [] (StringBuilder.))
     :cljs (fn [] "")))

(def string-builder-append-code-point
  #?(:clj (fn [^StringBuilder sb cp] (.appendCodePoint sb cp))
     :cljs (fn [acc cp] (str acc (js/String.fromCodePoint cp)))))

(def string-builder-to-string
  #?(:clj (fn [^StringBuilder sb] (.toString sb))
     :cljs (fn [acc] acc)))

(def to-lower-case
  #?(:clj (fn [cp] (Character/toLowerCase cp))
     :cljs (fn [cp] (.codePointAt (.toLowerCase (js/String.fromCodePoint cp)) 0))))

(defn case-fold [s]
  (let [cps (string-to-codepoints s)
        sb (reduce (fn [acc cp]
                     (reduce string-builder-append-code-point
                             acc
                             (or (get case-fold-map cp) [(to-lower-case cp)])))
                   (string-builder)
                   cps)]
    (string-builder-to-string sb)))

(def to-ascii
  #?(:clj (fn [label] (IDN/toASCII label))
     :cljs (fn [label]
             (let [low (str/lower-case label)
                   nf1 (normalise-nfkc low)
                   cf (case-fold nf1)
                   mapped (normalise-nfkc cf)]
               (let [encoded (punycode/encode mapped)]
                 (if (re-matches #"[a-z0-9-]+" mapped)
                   mapped
                   (str "xn--" encoded)))))))

(defn codepoints-to-string [cps]
  (let [sb (string-builder)]
    (doseq [cp cps]
      (string-builder-append-code-point sb cp))
    (string-builder-to-string sb)))

(def to-unicode
  #?(:clj (fn [label] (IDN/toUnicode label))
     :cljs (fn [label]
             (let [low (str/lower-case label)]
               (if (str/starts-with? low "xn--")
                 (punycode/decode (subs low 4))
                 label)))))

(def unicode-script-of
  #?(:clj (fn [cp] (keyword (.name (Character$UnicodeScript/of cp))))
     :cljs (fn [cp]
             (let [s (js/String.fromCodePoint cp)]
               (cond
                 (.match s (js/RegExp "\\p{Script=Greek}" "u")) :GREEK
                 (.match s (js/RegExp "\\p{Script=Hebrew}" "u")) :HEBREW
                 (.match s (js/RegExp "\\p{Script=Hiragana}" "u")) :HIRAGANA
                 (.match s (js/RegExp "\\p{Script=Katakana}" "u")) :KATAKANA
                 (.match s (js/RegExp "\\p{Script=Han}" "u")) :HAN
                 (.match s (js/RegExp "\\p{Script=Hangul}" "u")) :HANGUL
                 (.match s (js/RegExp "\\p{Script=Arabic}" "u")) :ARABIC
                 (.match s (js/RegExp "\\p{Script=Devanagari}" "u")) :DEVANAGARI
                 :else nil)))))

(def CHARACTER_UPPERCASE_LETTER        1)
(def CHARACTER_LOWERCASE_LETTER        2)
(def CHARACTER_OTHER_LETTER            5)
(def CHARACTER_DECIMAL_DIGIT_NUMBER    9)
(def CHARACTER_MODIFIER_LETTER         4)
(def CHARACTER_NON_SPACING_MARK        6)
(def CHARACTER_ENCLOSING_MARK          7)
(def CHARACTER_COMBINING_SPACING_MARK  8)
(def CHARACTER_FORMAT                  16)
(def CHARACTER_DASH_PUNCTUATION        20)
(def CHARACTER_OTHER_PUNCTUATION       24)
(def CHARACTER_MODIFIER_SYMBOL         4)
(def CHARACTER_OTHER_SYMBOL            28)

(def get-char-type
  #?(:clj (fn [cp] (Character/getType cp))
     :cljs (fn [cp]
             (let [s (js/String.fromCodePoint cp)]
               (cond
                 (.match s (js/RegExp "\\p{Lu}" "u")) CHARACTER_UPPERCASE_LETTER
                 (.match s (js/RegExp "\\p{Ll}" "u")) CHARACTER_LOWERCASE_LETTER
                 (.match s (js/RegExp "\\p{Lo}" "u")) CHARACTER_OTHER_LETTER
                 (.match s (js/RegExp "\\p{Nd}" "u")) CHARACTER_DECIMAL_DIGIT_NUMBER
                 (.match s (js/RegExp "\\p{Lm}" "u")) CHARACTER_MODIFIER_LETTER
                 (.match s (js/RegExp "\\p{Mn}" "u")) CHARACTER_NON_SPACING_MARK
                 (.match s (js/RegExp "\\p{Me}" "u")) CHARACTER_ENCLOSING_MARK
                 (.match s (js/RegExp "\\p{Mc}" "u")) CHARACTER_COMBINING_SPACING_MARK
                 (.match s (js/RegExp "\\p{Pd}" "u")) CHARACTER_DASH_PUNCTUATION
                 (.match s (js/RegExp "\\p{Po}" "u")) CHARACTER_OTHER_PUNCTUATION
                 (.match s (js/RegExp "\\p{Cf}" "u")) CHARACTER_FORMAT
                 (.match s (js/RegExp "\\p{Sk}" "u")) CHARACTER_MODIFIER_SYMBOL
                 (.match s (js/RegExp "\\p{So}" "u")) CHARACTER_OTHER_SYMBOL
                 :else 0)))))

(def is-defined
  #?(:clj (fn [cp] (Character/isDefined cp))
     :cljs (fn [cp]
             (and (<= 0 cp 0x10ffff)
                  (or (not= (get-char-type cp) 0)
                      (= cp 0x002D)))))); Special for hyphen

(def is-whitespace
  #?(:clj (fn [cp] (Character/isWhitespace cp))
     :cljs (fn [cp]
             (let [s (js/String.fromCodePoint cp)]
               (boolean (.match s (js/RegExp "\\s" "u")))))))

;;------------------------------------------------------------------------------

(def exceptions {0x00df :pvalid
                 0x03c2 :pvalid
                 0x06fd :pvalid
                 0x06fe :pvalid
                 0x0f0b :pvalid
                 0x3007 :pvalid
                 0x0640 :disallowed
                 0x07fa :disallowed
                 0x302e :disallowed
                 0x302f :disallowed
                 0x3031 :disallowed
                 0x3032 :disallowed
                 0x3033 :disallowed
                 0x3034 :disallowed
                 0x3035 :disallowed
                 0x303b :disallowed})

(def context-map {0x200c :contextj
                  0x200d :contextj
                  0x00b7 :contexto
                  0x0375 :contexto
                  0x05f3 :contexto
                  0x05f4 :contexto
                  0x30fb :contexto})

(def joining-type-map {0x0620 "U"
                       0x0621 "U"
                       0x0622 "R"
                       0x0623 "R"
                       0x0624 "R"
                       0x0625 "R"
                       0x0626 "D"
                       0x0627 "R"
                       0x0628 "D"
                       0x0629 "R"
                       0x062A "D"
                       0x062B "D"
                       0x062C "D"
                       0x062D "D"
                       0x062E "D"
                       0x062F "R"
                       0x0630 "R"
                       0x0631 "R"
                       0x0632 "R"
                       0x0633 "D"
                       0x0634 "D"
                       0x0635 "D"
                       0x0636 "D"
                       0x0637 "D"
                       0x0638 "D"
                       0x0639 "D"
                       0x063A "D"
                       0x063B "D"
                       0x063C "D"
                       0x063D "D"
                       0x063E "D"
                       0x063F "D"
                       0x0641 "D"
                       0x0642 "D"
                       0x0643 "D"
                       0x0644 "D"
                       0x0645 "D"
                       0x0646 "D"
                       0x0647 "D"
                       0x0648 "R"
                       0x0649 "D"
                       0x064A "D"})

(def ccc-map {0x094d 9
              0x09CD 9
              0x0A4D 9
              0x0ACD 9
              0x0B4D 9
              0x0BCD 9
              0x0C4D 9
              0x0CCD 9
              0x0D4D 9
              0x0DCD 9
              0x0F84 9})

(defn joining-type [cp]
  (get joining-type-map cp "U"))

(defn noncharacter? [cp]
  (or (<= 0xfdd0 cp 0xfdef)
      (let [low (bit-and cp 0xffff)]
        (and (<= 0 (bit-shift-right cp 16) 0x10) (or (= low 0xfffe) (= low 0xffff))))))

(defn ignorable-properties? [cp]
  (or (is-whitespace cp)
      (= (get-char-type cp) CHARACTER_FORMAT)
      (noncharacter? cp)))

(defn ignorable-blocks? [cp]
  (or (<= 0x20d0 cp 0x20ff)
      (<= 0x1d100 cp 0x1d1ff)
      (<= 0x1d200 cp 0x1d24f)))

(defn letter-digit? [cp]
  (let [type (get-char-type cp)]
    (or (= type CHARACTER_UPPERCASE_LETTER)
        (= type CHARACTER_LOWERCASE_LETTER)
        (= type CHARACTER_OTHER_LETTER)
        (= type CHARACTER_DECIMAL_DIGIT_NUMBER)
        (= type CHARACTER_MODIFIER_LETTER)
        (= type CHARACTER_NON_SPACING_MARK)
        (= type CHARACTER_COMBINING_SPACING_MARK))))

(defn unstable? [cp]
  (let [s (codepoints-to-string [cp])
        nf1 (normalise-nfkc s)
        cf (case-fold nf1)
        nf2 (normalise-nfkc cf)]
    (not (= nf2 s))))

(defn get-derived-property [cp]
  (or (get context-map cp)
      (get exceptions cp)
      (if-not (is-defined cp) :unassigned
              (if (unstable? cp) :disallowed
                  (if (ignorable-properties? cp) :disallowed
                      (if (ignorable-blocks? cp) :disallowed
                          (if (or (letter-digit? cp) (= cp 0x002D)) :pvalid
                              :disallowed)))))))

(defn check-context-rule [cp codepoints idx]
  (case cp
    0x200d (and (> idx 0) (= 9 (get ccc-map (nth codepoints (dec idx)) 0)))
    0x200c (or (and (> idx 0) (= 9 (get ccc-map (nth codepoints (dec idx)) 0)))
               (let [left-idx (loop [j (dec idx)]
                                (cond
                                  (< j 0) nil
                                  (= "T" (joining-type (nth codepoints j))) (recur (dec j))
                                  :else j))
                     right-idx (loop [j (inc idx)]
                                 (cond
                                   (>= j (count codepoints)) nil
                                   (= "T" (joining-type (nth codepoints j))) (recur (inc j))
                                   :else j))]
                 (when (and left-idx right-idx)
                   (let [left-jt (joining-type (nth codepoints left-idx))
                         right-jt (joining-type (nth codepoints right-idx))]
                     (and (or (= "R" left-jt) (= "D" left-jt))
                          (or (= "L" right-jt) (= "D" right-jt)))))))
    0x00b7 (and (> idx 0) (< idx (dec (count codepoints)))
                (= (nth codepoints (dec idx)) 0x006C)
                (= (nth codepoints (inc idx)) 0x006C))
    0x0375 (and (< idx (dec (count codepoints)))
                (= :GREEK (unicode-script-of (nth codepoints (inc idx)))))
    0x05f3 (and (> idx 0)
                (= :HEBREW (unicode-script-of (nth codepoints (dec idx)))))
    0x05f4 (and (> idx 0)
                (= :HEBREW (unicode-script-of (nth codepoints (dec idx)))))
    0x30fb (some (fn [c] (and (not= c 0x30fb)
                              (let [script (unicode-script-of c)]
                                (or (= script :HIRAGANA)
                                    (= script :KATAKANA)
                                    (= script :HAN))))) codepoints)
    false))

(defn validate-u-label [label]
  (let [codepoints (string-to-codepoints label)]
    (when-not (empty? codepoints)
      (let [first-type (get-char-type (first codepoints))]
        (when-not (or (= first-type CHARACTER_NON_SPACING_MARK)
                      (= first-type CHARACTER_ENCLOSING_MARK)
                      (= first-type CHARACTER_COMBINING_SPACING_MARK))
          (let [arabic? (some #(<= 0x0660 % 0x0669) codepoints)
                ext? (some #(<= 0x06f0 % 0x06f9) codepoints)]
            (when-not (and arabic? ext?)
              (and (not (and (>= (count label) 4) (= (subs label 2 4) "--")))
                   (every? (fn [[idx prop]]
                             (or (= :pvalid prop)
                                 (and (#{:contextj :contexto} prop)
                                      (check-context-rule (nth codepoints idx) codepoints idx))))
                           (map-indexed vector (map get-derived-property codepoints)))))))))))

(defn validate-label [label]
  (and (not (str/blank? label))
       (<= (count label) 63)
       (not (str/starts-with? label "-"))
       (not (str/ends-with? label "-"))
       (if (str/starts-with? (str/lower-case label) "xn--")
         (try
           (let [u-label (to-unicode label)
                 encoded (to-ascii u-label)]
             (and (= label (str/lower-case encoded))
                  (validate-u-label u-label)))
           (catch Exception _ false))
         (try
           (let [a-label (to-ascii label)]
             (and (<= (count a-label) 63)
                  (validate-u-label label)))
           (catch Exception _ false)))))

(defn json-idn-hostname? [data]
  (if-not (string? data)
    true
    (try
      (let [s (str/replace data #"[\u3002\uff0e\uff61]" ".")]
        (and (not (str/blank? s))
             (not (str/starts-with? s "."))
             (not (str/ends-with? s "."))
             (not (str/includes? s ".."))
             (every? validate-label (str/split s #"\."))))
      (catch Exception _
        false))))
